<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jet Test</title>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
</head>

<body style="background: #222; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0;">

    <canvas id="gameCanvas" width="1000" height="700" style="border:2px solid white; background: #000;"></canvas>

    <script>
        $(document).ready(function () {
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");
            let pxpos = ((canvas.width) / 2) - 25, pypos = canvas.height - 100;
            const playerspeed = 10;
            let isinvincible = false;
            let speedinc = 0.2
            // images objects
            const jetImg = new Image();
            jetImg.src = "jet.webp"
            const thufo1 = new Image();
            thufo1.src = "thufo1.webp"
            const thufo2 = new Image();
            thufo2.src = "thufo2.webp"
            const thufo3 = new Image();
            thufo3.src = "thufo3.webp"
            const thufo4 = new Image();
            thufo4.src = "thufo4.webp"
            const thufo5 = new Image();
            thufo5.src = "thufo5.webp"
            const thufo6 = new Image();
            thufo6.src = "thufo6.webp"
            const thufo7 = new Image();
            thufo7.src = "thufo7.webp"
            const thufo8 = new Image();
            thufo8.src = "thufo8.webp"
            const thufo9 = new Image();
            thufo9.src = "thufo9.webp"
            const thufo10 = new Image();
            thufo10.src = "thufo10.webp"
            const ufo1 = new Image();
            ufo1.src = "ufo1.webp"
            const ufo2 = new Image();
            ufo2.src = "ufo2.webp"
            const ufo3 = new Image();
            ufo3.src = "ufo3.webp"
            const ufo4 = new Image();
            ufo4.src = "ufo4.webp"
            const ufo5 = new Image();
            ufo5.src = "ufo5.webp"
            const ufo6 = new Image();
            ufo6.src = "ufo6.webp"
            const ufo7 = new Image();
            ufo7.src = "ufo7.webp"
            const ufo8 = new Image();
            ufo8.src = "ufo8.webp"
            const ufo9 = new Image();
            ufo9.src = "ufo9.webp"
            const ufo10 = new Image();
            ufo10.src = "ufo10.webp"
            const ufo11 = new Image();
            ufo11.src = "ufo11.webp"
            const ufo12 = new Image();
            ufo12.src = "ufo12.webp"
            const life = new Image();
            life.src = "life.webp"
            const bullet = new Image();
            bullet.src = "bullet.webp"
            const boss1 = new Image();
            boss1.src = "boss1.webp"
            const boss2 = new Image();
            boss2.src = "boss2.webp"
            const boss3 = new Image();
            boss3.src = "boss3.webp"
            const ten1right = new Image();
            ten1right.src = "ten1right.webp"
            const ten1left = new Image();
            ten1left.src = "ten1left.webp"
            const ten2right = new Image();
            ten2right.src = "ten2right.webp"
            const ten2left = new Image();
            ten2left.src = "ten2left.webp"
            const firepower = new Image();
            firepower.src = "firepower.webp"
            const rocket = new Image();
            rocket.src = "rocket (leftcornerup).webp"
            const rocket1 = new Image();
            rocket1.src = "rocket (rightcornerup).webp"
            const rocket2 = new Image();
            rocket2.src = "rocket (rightcornerdown).webp"
            const rocket3 = new Image();
            rocket3.src = "rocket (leftcornerdown).webp"
            const meteor = new Image();
            meteor.src = "meteor.webp"
            const coin = new Image();
            coin.src = "coin.webp"
            const gear = new Image();
            gear.src = "gear.webp"
            const blast = new Image();
            blast.src = "blast.webp"
            let inc = 0
            let rxpos
            let rypos
            let firedrockets = []
            let explosions = []
            let bossenemyexplosions = []
            let lastrocketcount = 0
            let firerocket = []
            let rocketfireflag = false
            let weights = [1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4] // random prize generating array
            for (let i = 0; i <= 100; i++) {
                weights.push(1)
            }
            let bosslife
            let bossMissiles = [];
            let noscore = true
            let prize = []
            let score = 0;
            let lifecount = 3; // Initial life count
            let firepowercount = 0; // Initial firepower count
            let firepowerinc = 0; // firepower increment
            let rocketcount = 0; // Initial rocket count
            let rocketcountinc = 0; // rocket increment
            //array for bullets
            let bullets = [];
            const bulletSpeed = 10;
            let blastflag = false
            // 1. Array to hold multiple enemies
            let pushflag = true
            let enemies = [
                { id: ufo1, expos: 400, eypos: -100 * Math.random() - 35 * Math.random(), speed: 2 * speedinc, killcount: 4 },
                { id: ufo2, expos: 700, eypos: -205 * Math.random() - 35 * Math.random(), speed: 1.5 * speedinc, killcount: 4 },
                { id: ufo3, expos: 100, eypos: -206 * Math.random() - 35 * Math.random(), speed: 3 * speedinc, killcount: 4 },
                { id: ufo4, expos: 200, eypos: -307 * Math.random() - 35 * Math.random(), speed: 4 * speedinc, killcount: 4 },
                { id: ufo5, expos: 300, eypos: -104 * Math.random() - 35 * Math.random(), speed: 2.5 * speedinc, killcount: 4 },
                { id: ufo6, expos: 500, eypos: -303 * Math.random() - 35 * Math.random(), speed: 1 * speedinc, killcount: 4 },
                { id: ufo7, expos: 600, eypos: -706 * Math.random() - 35 * Math.random(), speed: 3.5 * speedinc, killcount: 4 },
                { id: ufo8, expos: 800, eypos: -906 * Math.random() - 35 * Math.random(), speed: 2.8 * speedinc, killcount: 4 },
                { id: ufo9, expos: 900, eypos: -980 * Math.random() - 35 * Math.random(), speed: 1.2 * speedinc, killcount: 4 },
                { id: ufo10, expos: 150, eypos: -507 * Math.random() - 35 * Math.random(), speed: 4.5 * speedinc, killcount: 4 },
                { id: ufo11, expos: 250, eypos: -705 * Math.random() - 35 * Math.random(), speed: 3.2 * speedinc, killcount: 4 },
                { id: ufo12, expos: 350, eypos: -604 * Math.random() - 35 * Math.random(), speed: 2.3 * speedinc, killcount: 4 }

            ];
            let enemyweights = [1, 2, 3, 4, 5, 6]
            let firetimer = 1


            //  boss
            let firstboss = {
                img: boss1,
                x: 400,
                y: -200, // Start off-screen
                active: false,
                speedX: 2,
                health: 30
            };
            let bossexplosions = []
            let boss1enemies = [];
            let boss2enemies = []
            let bossenemiesarr = [
                { id: ufo1, expos: firstboss.x, eypos: firstboss.y, speed: 3.5, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo2, expos: firstboss.x, eypos: firstboss.y, speed: 2.8, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo3, expos: firstboss.x, eypos: firstboss.y, speed: 1.2, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo4, expos: firstboss.x, eypos: firstboss.y, speed: 4.5, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo5, expos: firstboss.x, eypos: firstboss.y, speed: 3.2, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo6, expos: firstboss.x, eypos: firstboss.y, speed: 2.3, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 }];
            let secondboss = {
                img: boss2,
                x: 400,
                y: -200, // Start off-screen
                active: false,
                speedX: 2,
                health: 30,
                bullets: [],
                firetimer: 0
            };


            let thirdboss = {
                img: boss3,
                x: 400,
                y: -200, // Start off-screen
                active: false,
                speedX: 2,
                health: 30
            };
            let firetimerth = 0.5
            let boss2enemiesarr = [
                { id: thufo1, expos: thirdboss.x, eypos: thirdboss.y, speed: 3, timer: Math.floor(Math.random() * 300) + 30 * firetimerth, killcount: 4 },
                { id: thufo2, expos: thirdboss.x, eypos: thirdboss.y, speed: 3, timer: Math.floor(Math.random() * 300) + 30 * firetimerth, killcount: 4 },
                { id: thufo3, expos: thirdboss.x, eypos: thirdboss.y, speed: 3, timer: Math.floor(Math.random() * 300) + 30 * firetimerth, killcount: 4 },
                { id: thufo4, expos: thirdboss.x, eypos: thirdboss.y, speed: 3, timer: Math.floor(Math.random() * 300) + 30 * firetimerth, killcount: 4 },
                { id: thufo5, expos: thirdboss.x, eypos: thirdboss.y, speed: 3, timer: Math.floor(Math.random() * 300) + 30 * firetimerth, killcount: 4 },
                { id: thufo6, expos: thirdboss.x, eypos: thirdboss.y, speed: 3, timer: Math.floor(Math.random() * 300) + 30 * firetimerth, killcount: 4 },
                { id: thufo7, expos: thirdboss.x, eypos: thirdboss.y, speed: 3, timer: Math.floor(Math.random() * 300) + 30 * firetimerth, killcount: 4 },
                { id: thufo8, expos: thirdboss.x, eypos: thirdboss.y, speed: 3, timer: Math.floor(Math.random() * 300) + 30 * firetimerth, killcount: 4 },
                { id: thufo9, expos: thirdboss.x, eypos: thirdboss.y, speed: 3, timer: Math.floor(Math.random() * 300) + 30 * firetimerth, killcount: 4 },
                { id: thufo10, expos: thirdboss.x, eypos: thirdboss.y, speed: 3, timer: Math.floor(Math.random() * 300) + 30 * firetimerth, killcount: 4 },

            ];
            let boss3enemiesarr = [
                { id: ufo1, expos: thirdboss.x, eypos: thirdboss.y, speed: 3.5, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo2, expos: thirdboss.x, eypos: thirdboss.y, speed: 2.8, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo3, expos: thirdboss.x, eypos: thirdboss.y, speed: 1.2, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo4, expos: thirdboss.x, eypos: thirdboss.y, speed: 4.5, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo5, expos: thirdboss.x, eypos: thirdboss.y, speed: 3.2, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo6, expos: thirdboss.x, eypos: thirdboss.y, speed: 2.3, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo7, expos: thirdboss.x, eypos: thirdboss.y, speed: 3.5, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo8, expos: thirdboss.x, eypos: thirdboss.y, speed: 2.8, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo9, expos: thirdboss.x, eypos: thirdboss.y, speed: 1.2, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo10, expos: thirdboss.x, eypos: thirdboss.y, speed: 4.5, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo11, expos: thirdboss.x, eypos: thirdboss.y, speed: 3.2, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 },
                { id: ufo12, expos: thirdboss.x, eypos: thirdboss.y, speed: 2.3, timer: Math.floor(Math.random() * 300) + 30 * firetimer, killcount: 4 }
            ]
            let ang1l = 0
            let ang2l = 0
            let ang1r = 0
            let ang2r = 0

            // boss


            let keys = {
                ArrowRight: false,
                ArrowLeft: false,
                ArrowUp: false,
                ArrowDown: false,
                Spacebar: false,
                Enter: false
            }


            $(window).on('keydown', function (e) {
                if (e.key == "ArrowRight") keys.ArrowRight = true;
                if (e.key == "ArrowLeft") keys.ArrowLeft = true;
                if (e.key == "ArrowUp") keys.ArrowUp = true;
                if (e.key == "ArrowDown") keys.ArrowDown = true;
                if (e.key == "Enter") keys.Enter = true;
                if (e.key == " ") keys.Spacebar = true;

            });

            $(window).on('keyup', function (e) {
                if (e.key == "ArrowRight") keys.ArrowRight = false;
                if (e.key == "ArrowLeft") keys.ArrowLeft = false;
                if (e.key == "ArrowUp") keys.ArrowUp = false;
                if (e.key == "ArrowDown") keys.ArrowDown = false;
                if (e.key == "Enter") keys.Enter = false;
                if (e.key == " ") keys.Spacebar = false;
            });


            // Main Game Loop

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // player animations start
                if (keys.ArrowLeft) pxpos -= playerspeed;
                if (keys.ArrowUp) pypos -= playerspeed;
                if (keys.ArrowDown) pypos += playerspeed;
                if (keys.ArrowRight) pxpos += playerspeed;
                if (keys.ArrowLeft && keys.ArrowUp) pxpos -= playerspeed; pypos -= playerspeed;
                if (keys.ArrowLeft && keys.ArrowDown) pxpos -= playerspeed; pypos += playerspeed;
                if (keys.ArrowRight && keys.ArrowUp) pxpos += playerspeed; pypos -= playerspeed;
                if (keys.ArrowRight && keys.ArrowDown) pxpos += playerspeed; pypos += playerspeed;



                // Draw Player
                if (jetImg.complete) {
                    ctx.drawImage(jetImg, pxpos, pypos, 50, 50);
                }
                // player animations end

                // main stuff


                // Change your calls in the animate function to this:
                if (score <= 10) speedinc = 0.2; enemyspawning()
                if (score >= 10 && firstboss.health > 0) {
                    noscore = false
                    bossfight(firstboss);

                }

                if (score <= 81 && firstboss.health <= 0) noscore = true; speedinc = 0.4; enemyspawning()

                if (score >= 81 && secondboss.health > 0) {
                    noscore = false;
                    bossfight(secondboss);
                }
                if (score <= 150 && secondboss.health <= 0 && firstboss.health <= 0) noscore = true; speedinc = 1.2; enemyspawning()

                if (score >= 150 && thirdboss.health > 0) {
                    noscore = false;
                    bossfight(thirdboss)
                    boss3fight()
                }

                // main stuff
                //  Collision logic start
                enemies.forEach(enemy => {
                    if (pxpos < enemy.expos + 50 &&
                        pxpos + 50 > enemy.expos &&
                        pypos < enemy.eypos + 50 &&
                        pypos + 50 > enemy.eypos) {
                        if (isinvincible) {
                            return
                        }
                        if (!isinvincible) {
                            // Remove one life
                            lifecount--
                            explosions.push({ id: blast, blastxpos: enemy.expos, blastypos: enemy.eypos, speed: enemy.speed, timer: 30 })
                            ctx.clearRect(enemy.expos, enemy.eypos, 50, 50) // Clear the enemy from the canvas
                            enemy.eypos = -enemy.eypos - 10
                            enemy.expos = Math.random() * (canvas.width - 50); // Respawn the enemy at a new random position
                            isinvincible = true; // Set invincibility to prevent multiple collisions in a short time
                            setTimeout(() => {
                                isinvincible = false; // Reset invincibility after 3 seconds
                            }, 3000)
                        }

                    }

                })
                //collision logic end
                //  score logic start
                ctx.fillStyle = "white"
                ctx.font = "20px Arial"
                ctx.fillText("Score: " + score, canvas.width - 100, canvas.height - 20)
                //  score logic end
                // Lives logic start     
                ctx.drawImage(life, 20, 20, 40, 40)
                ctx.fillStyle = "white"
                ctx.font = "20px Arial"
                ctx.fillText(lifecount, 60, 50)
                //  lives logic end
                // firepower logic start
                ctx.drawImage(firepower, canvas.width - 80, 20, 40, 40)
                ctx.fillStyle = "white"
                ctx.font = "20px Arial"
                firepowercount = Math.floor(firepowerinc / 10)
                ctx.fillText(firepowercount, canvas.width - 40, 50)
                //  firepower logic end
                // rocket logic start
                ctx.drawImage(rocket, canvas.width - 150, 20, 40, 40)
                ctx.fillStyle = "white"
                ctx.font = "20px Arial"
                rocketcount = Math.floor(rocketcountinc / 1)
                ctx.fillText(rocketcount, canvas.width - 110, 50)
                // boss explosion logic start
                bossexplosions.forEach((bossexplosion, bossexplosionindex) => {
                    ctx.drawImage(bossexplosion.id, bossexplosion.blastxpos, bossexplosion.blastypos, 100, 100)
                    bossexplosion.timer--
                    if (bossexplosion.timer <= 0) {
                        bossexplosions.splice(bossexplosionindex, 1)
                    }
                })
                // bossexplosion logic end
                //  rocket fire logic start
                if (firstboss.active) bosslife = firstboss
                if (secondboss.active) bosslife = secondboss
                if (thirdboss.active) bosslife = thirdboss

                function resettimer() {
                    rocketfireflag = false
                    inc = 0
                }
                if (keys.Enter && !rocketfireflag) {
                    rxpos = pxpos
                    rypos = pypos
                    rocketfireflag = true
                    // rockettimer = setTimeout(() => {
                    //     resettimer()
                    // }, 10000)
                }
                if (rocketfireflag) {
                    inc = 3 + inc
                    if (rxpos > canvas.width / 2 && rypos < canvas.height / 2) {
                        ctx.drawImage(rocket2, rxpos - inc, rypos + inc, 100, 100)
                        if (rxpos - inc < canvas.width / 2 && rypos + inc > canvas.height / 2) {
                            firedrockets.push({ id: blast, rbxpos: rxpos - inc, rbypos: rypos + inc, timer: 30 })
                            if (firstboss.active || secondboss.active || thirdboss.active) { bossexplo(); rocketbosshealthdecrement(bosslife) }
                            else explo()
                            resettimer()
                        }
                    }
                    else if (rxpos > canvas.width / 2 && rypos > canvas.height / 2) {
                        ctx.drawImage(rocket1, rxpos - inc, rypos - inc, 100, 100)
                        if (rxpos - inc < canvas.width / 2 && rypos - inc < canvas.height / 2) {
                            firedrockets.push({ id: blast, rbxpos: rxpos - inc, rbypos: rypos - inc, timer: 30 })
                            if (firstboss.active || secondboss.active || thirdboss.active) { bossexplo(); rocketbosshealthdecrement(bosslife) }
                            else explo()
                            resettimer()

                        }
                    }
                    else if (rxpos < canvas.width / 2 && rypos > canvas.height / 2) {
                        ctx.drawImage(rocket, rxpos + inc, rypos - inc, 100, 100)
                        if (rxpos + inc > canvas.width / 2 && rypos - inc < canvas.height / 2) {
                            firedrockets.push({ id: blast, rbxpos: rxpos + inc, rbypos: rypos - inc, timer: 30 })
                            if (firstboss.active || secondboss.active || thirdboss.active) { bossexplo(); rocketbosshealthdecrement(bosslife) }
                            else explo()
                            resettimer()
                        }
                    }
                    else if (rxpos < canvas.width / 2 && rypos < canvas.height / 2) {
                        ctx.drawImage(rocket3, rxpos + inc, rypos + inc, 100, 100)
                        if (rxpos + inc > canvas.width / 2 && rypos + inc > canvas.height / 2) {
                            firedrockets.push({ id: blast, rbxpos: rxpos + inc, rbypos: rypos + inc, timer: 30 })
                            if (firstboss.active || secondboss.active || thirdboss.active) { bossexplo(); rocketbosshealthdecrement(bosslife) }
                            else explo()
                            resettimer()
                        }
                    }
                    // ctx.drawImage(rocket3, rxpos + inc, rypos - inc, 100, 100)
                }
                // rocketcount--    
                // lastrocketcount = rocketcount
                // rocket fire logic end
                // rocket hit logic start
                firedrockets.forEach((firedrocket, firedrocketindex) => {
                    ctx.drawImage(firedrocket.id, firedrocket.rbxpos, firedrocket.rbypos, 200, 200)
                    firedrocket.timer--
                    if (firedrocket.timer <= 0) {
                        firedrockets.splice(firedrocketindex, 1)
                        // ctx.clearRect(firedrocket.rbxpos, firedrocket.rbypos, 200, 200)
                    }
                })
                // rocket hit logic end
                // rocket logic end
                // fire logic start
                function fireBullet() {
                    // Create a bullet object and add it to an array of bullets
                    let bulletobject = { id: bullet, bxpos: pxpos, bypos: pypos - 25, speed: bulletSpeed }; // Start bullet at player's position};
                    bullets.push(bulletobject);

                }
                if (keys.Spacebar) { // Spacebar to fire
                    fireBullet();
                    keys.Spacebar = false;
                }
                bullets.forEach(bull => {
                    bull.bypos -= bull.speed// Move the bullet upwards
                    ctx.drawImage(bull.id, bull.bxpos + 20, bull.bypos, 10, 20); // Draw the bullet immediately when fired
                    if (bull.bypos < 0)
                        bullets.shift()
                });
                // fire logic 
                // enemy hit logic start
                bullets.forEach((bull, bullindex) => {
                    enemies.forEach((enemy, enemyIndex) => {
                        if (bull.bxpos < enemy.expos + 25 &&
                            bull.bxpos + 25 > enemy.expos &&
                            bull.bypos < enemy.eypos + 25 &&
                            bull.bypos + 25 > enemy.eypos
                        ) {
                            enemy.killcount = enemy.killcount - firepowercount - 1
                            bullets.splice(bullindex, 1) // Remove the bullet that hit the enemy
                            console.log(firepowercount)
                            console.log(enemy.killcount)
                            if (enemy.killcount <= 0) {

                                dropEnemyPrize(enemy, weights, prize)

                                enemy.eypos = -enemy.eypos - 10
                                enemy.killcount = 4
                                enemy.expos = Math.random() * (canvas.width - 50); // Respawn the enemy at a new random position
                                bullets.splice(bullindex, 1) // Remove the bullet that hit the enemy
                                if (noscore) score++
                            }
                        }
                    })

                });
                // enemy hit logic end
                // explosion draw logic start
                explosions.forEach((explosion, explosionindex) => {
                    ctx.drawImage(explosion.id, explosion.blastxpos, explosion.blastypos, 50, 50)
                    explosion.timer--
                    if (explosion.timer <= 0) {
                        explosions.splice(explosionindex, 1)
                    }
                })
                // explosion draw logic end
                // prize logic start
                prize.forEach((prizeitem, prizeindex) => {
                    ctx.drawImage(prizeitem.id, prizeitem.lxpos, prizeitem.lypos, 30, 30)
                    prizeitem.lypos += prizeitem.lspeed;
                    if (prizeitem.lypos > canvas.height) prize.splice(prizeindex, 1);


                    if (prizeitem.lxpos < pxpos + 50 &&
                        prizeitem.lxpos + 50 > pxpos &&
                        prizeitem.lypos < pypos + 50 &&
                        prizeitem.lypos + 50 > pypos) {
                        if (prizeitem.type == "life") {
                            lifecount++
                        }
                        else if (prizeitem.type == "firepower") {
                            firepowerinc++

                        }
                        else if (prizeitem.type == "score") {
                            if (noscore) score++
                        }
                        else if (prizeitem.type == "gear") {
                            rocketcountinc++
                        }
                        prize.splice(prizeindex, 1)
                    }

                })
                // enemy animation start
                function enemyspawning() {
                    if (!firstboss.active && !secondboss.active && !thirdboss.active) {
                        //    enemies.forEach(enemy => {
                        //             enemy.expos = Math.random() * (canvas.width - 50); // Random x position within canvas width
                        //         })

                        enemies.forEach(enemy => {

                            enemy.eypos += enemy.speed; // Move the enemy downwards based on its speed
                            enemyimg = enemy.id;
                            if (enemy.eypos > canvas.height) {
                                enemy.eypos = -50;

                                enemy.expos = Math.random() * (canvas.width - 50);

                            }

                            ctx.drawImage(enemyimg, enemy.expos, enemy.eypos, 50, 50);
                        });
                    }
                }
                // enemy animation end 
                // explosion function
                function explo() {
                    enemies.forEach(enemy => {
                        // ctx.clearRect(enemy.expos, enemy.eypos, 50, 50) // Clear the enemy from the canvas
                        dropEnemyPrize(enemy, weights, prize, true)

                        // console.log(prize)


                    })
                }
                // explosion function
                // boss explosion function
                function bossexplo() {
                    boss1enemies.forEach((enemy, enemyIndex) => {

                        // ctx.clearRect(enemy.expos, enemy.eypos, 50, 50) // Clear the enemy from the canvas
                        dropEnemyPrize(enemy, weights, prize, false)
                        boss1enemies.splice(enemyIndex, 1)
                        // boss1enemies = [];
                        // console.log(prize)

                    })
                }
                // boss explosion function
                // prize logic end
                // boss dead logic start
                function handleBossDeath(bossObj) {
                    if (!bossObj.active) return; // EXIT IMMEDIATELY if already dead
                    // 1. Create multiple random explosions over the boss area
                    bossObj.active = false;
                    let deathx = bossObj.x
                    let deathy = bossObj.y
                    for (let i = 0; i < 5; i++) {
                        bossexplosions.push({
                            id: blast,
                            blastxpos: deathx + Math.random() * 250, // spread across boss width
                            blastypos: deathy + Math.random() * 150, // spread across boss height
                            speed: 0,
                            timer: 40 + (i * 10) // staggered timing
                        });
                    }


                    bossObj.y = -500; // Move it far off-screen

                    // 3. Clear the minions currently on screen
                    boss1enemies.length = 0;

                    // 4. Bonus for winning
                    score += 50;
                    console.log("bossdead")
                    // 2. Clear the boss and reset for the next phase


                }
                // boss death logic end     
                // Add this to your variable declarations at the top of your script
                // secondbossbullet fire logic start
                function fireSemiCircle(boss) {
                    // 1. Setup timing (only fire every 90 frames, about 1.5 seconds)
                    if (!boss.fireTimer) boss.fireTimer = 0;
                    boss.fireTimer++;

                    if (boss.fireTimer % 90 === 0) {
                        const numBullets = 7; // Number of bullets in the arc
                        const spread = Math.PI; // 180 degrees spread

                        for (let i = 0; i < numBullets; i++) {
                            // Calculate angle for each bullet: 
                            // 0 is right, Math.PI/2 is down, Math.PI is left
                            let angle = (i * (spread / (numBullets - 1)));

                            secondboss.bullets.push({
                                x: boss.x + 150, // Center of the 300px wide boss
                                y: boss.y + 150,
                                vx: Math.cos(angle) * 4, // Horizontal velocity
                                vy: Math.sin(angle) * 4, // Vertical velocity
                                size: 10
                            });
                        }

                    }

                    // 2. Update and Draw those bullets
                    secondboss.bullets.forEach((b, index) => {
                        b.x += b.vx;
                        b.y += b.vy;

                        // Draw bullet
                        ctx.fillStyle = "#FF00FF"; // Neon purple/pink for Boss 2
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                        ctx.fill();

                        // 3. Collision with Player (using your player variables)
                        if (b.x < pxpos + 50 && b.x + b.size > pxpos &&
                            b.y < pypos + 50 && b.y + b.size > pypos) {
                            if (isinvincible) {
                                return
                            }
                            if (!isinvincible) {
                                bossexplosions.push({ id: blast, blastxpos: pxpos - 20, blastypos: pypos - 30, speed: 1, timer: 30 })
                                lifecount--;
                                isinvincible = true;
                                setTimeout(() => { isinvincible = false; }, 3000);
                                secondboss.bullets.splice(index, 1);
                            }
                        }

                        // 4. Remove bullets that leave the screen to prevent lag
                        if (b.y > canvas.height || b.x < 0 || b.x > canvas.width) {
                            secondboss.bullets.splice(index, 1);
                        }

                        return

                    });

                }
                // second boss bullet fire logic end
                // boss1 logic end
                // boss logic start
                function drawRotatedTentacleleft(image, x, y, width, height, angle, flip = false) {
                    ctx.save();
                    ctx.translate(x, y); // This is the "Shoulder" where it attaches
                    ctx.rotate(angle);
                    if (flip) {
                        ctx.scale(-1, 1); // Flips the tentacle horizontally
                    }

                    // Draw at 0 for Y so the TOP of the image stays at the (x,y) point
                    ctx.drawImage(image, -width, -height / 2, width, height);

                    ctx.restore();
                }
                function drawRotatedTentacleright(image, x, y, width, height, angle, flip = false) {
                    ctx.save();
                    ctx.translate(x, y); // This is the "Shoulder" where it attaches
                    ctx.rotate(angle);
                    if (flip) {
                        ctx.scale(-1, 1); // Flips the tentacle horizontally
                    }

                    // Draw at 0 for Y so the TOP of the image stays at the (x,y) point
                    ctx.drawImage(image, 0, -height / 2, width, height);

                    ctx.restore();
                }
                // boss logic end
                // prize function
                function dropEnemyPrize(enemy, weights, prizeList, pflag) {
                    explosions.push({ id: blast, blastxpos: enemy.expos, blastypos: enemy.eypos, speed: enemy.speed, timer: 30 })



                    if (noscore) score++
                    let flag = weights[Math.floor(Math.random() * weights.length)];

                    // Shared properties to avoid repeating "enemy.expos" everywhere
                    const dropData = {
                        lxpos: enemy.expos,
                        lypos: enemy.eypos,
                        lspeed: enemy.speed
                    };

                    if (flag == 1) {
                        prizeList.push({ id: coin, type: "score", ...dropData });
                    }
                    else if (flag == 4) {
                        prizeList.push({ id: firepower, type: "firepower", ...dropData });
                    }
                    else if (flag == 2) {
                        prizeList.push({ id: gear, type: "gear", ...dropData });
                    }
                    else if (flag == 3) {
                        prizeList.push({ id: life, type: "life", ...dropData });
                    }
                    // prize function end
                    if (pflag) {
                        enemy.eypos = -enemy.eypos - 10
                        enemy.expos = Math.random() * (canvas.width - 50); // Respawn the enemy at a new random position

                    }
                    enemy.killcount = 4
                }
                function bossfight(boss) {
                    firetimer = 0.5
                    if (secondboss.active) {
                        fireSemiCircle(boss)
                    }

                    boss.active = true;

                    // Move boss into view
                    if (boss.y < 50) boss.y += 1;

                    // Boss Side-to-Side movement
                    boss.x += boss.speedX;
                    if (boss.x > canvas.width - 300 || boss.x < 0) boss.speedX *= -1;
                    if (boss.y >= 50) {
                        bossenemiesarr.forEach((enemy, enemyIndex) => {
                            let bossflag = enemyweights[Math.floor(Math.random() * enemyweights.length)]
                            if (bossflag == enemyIndex) {
                                enemy.timer--
                                if (enemy.timer <= 0) {
                                    enemy.eypos = boss.y + 100
                                    enemy.expos = boss.x + 125
                                    boss1enemies.push(enemy)
                                    enemy.timer = Math.floor(Math.random() * 300) + 30 * firetimer
                                }

                            }
                        })
                        boss1enemies.forEach((enemy, enemyIndex) => {
                            if (enemy.eypos > canvas.height || enemy.killcount <= 0) {
                                boss1enemies.splice(enemyIndex, 1)
                            }


                            enemy.eypos += enemy.speed; // Move the enemy downwards based on its speed
                            enemyimg = enemy.id;


                            ctx.drawImage(enemyimg, enemy.expos, enemy.eypos, 50, 50);
                        });
                    }
                    ctx.drawImage(boss.img, boss.x, boss.y, 300, 200);

                    //  Collision logic start
                    boss1enemies.forEach((enemy, enemyIndex) => {
                        if (pxpos < enemy.expos + 50 &&
                            pxpos + 50 > enemy.expos &&
                            pypos < enemy.eypos + 50 &&
                            pypos + 50 > enemy.eypos) {
                            if (isinvincible) {
                                return
                            }
                            if (!isinvincible) {
                                // Remove one life
                                lifecount--
                                explosions.push({ id: blast, blastxpos: enemy.expos, blastypos: enemy.eypos, speed: enemy.speed, timer: 30 })
                                boss1enemies.splice(enemyIndex, 1)
                                isinvincible = true; // Set invincibility to prevent multiple collisions in a short time
                                setTimeout(() => {
                                    isinvincible = false; // Reset invincibility after 3 seconds
                                }, 3000)
                            }

                        }

                    })

                    //collision logic 


                    // enemy hit logic start
                    bullets.forEach((bull, bullindex) => {
                        if (bull.bxpos < boss.x + 300 &&
                            bull.bxpos + 25 > boss.x &&
                            bull.bypos < boss.y + 100 &&
                            bull.bypos + 25 > boss.y
                        ) {

                            bossexplosions.push({ id: blast, blastxpos: bull.bxpos, blastypos: bull.bypos, speed: 1, timer: 3 })
                            bullets.splice(bullindex, 1)
                            boss.health = boss.health - firepowercount - 1
                            console.log(boss.health)

                        }
                        boss1enemies.forEach((enemy, enemyIndex) => {

                            if (bull.bxpos < enemy.expos + 25 &&
                                bull.bxpos + 25 > enemy.expos &&
                                bull.bypos < enemy.eypos + 25 &&
                                bull.bypos + 25 > enemy.eypos
                            ) {
                                enemy.killcount = enemy.killcount - firepowercount - 1
                                bullets.splice(bullindex, 1) // Remove the bullet that hit the enemy
                                console.log(firepowercount)
                                console.log(enemy.killcount)


                                if (enemy.killcount <= 0) {
                                    bossexplo()

                                }



                            }

                        })

                    });
                    // TRIGGER DEATH ANIMATION
                    if (boss.health <= 0) {
                        handleBossDeath(boss);

                    }
                    return; // Important: Stop processing this bullet since it's gone
                }
                function boss3fight() {

                    if (thirdboss.y >= 50) {
                        boss2enemiesarr.forEach((enemy, enemyIndex) => {
                            let bossflag = enemyweights[Math.floor(Math.random() * enemyweights.length)]
                            if (bossflag == enemyIndex) {
                                enemy.timer--
                                if (enemy.timer <= 0) {
                                    enemy.eypos = thirdboss.y + 100
                                    enemy.expos = thirdboss.x + 125
                                    boss2enemies.push(enemy)
                                    enemy.timer = Math.floor(Math.random() * 300) + 30 * firetimer
                                }

                            }
                        })
                    }

                    // 2. Homing Logic using only X and Y coordinates
                    boss2enemies.forEach((m, index) => {
                        // Calculate the distance (difference) on each axis
                        let dx = (pxpos + 25) - m.expos;
                        let dy = (pypos + 25) - m.eypos;

                        // Calculate total distance using Pythagorean theorem (sqrt(x^2 + y^2))
                        let distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 1) {
                            // Move the missile by a fraction of the distance based on speed
                            // This effectively "points" the missile at the player without angles
                            m.expos += (dx / distance) * 3;
                            m.eypos += (dy / distance) * 3;
                        }

                        // 3. Draw the Missile

                        ctx.drawImage(m.id, m.expos, m.eypos, 50, 50);

                        if (m.timer <= 0) {
                            explosions.push({ id: blast, blastxpos: m.expos, blastypos: m.eypos, speed: 3, timer: 30 })
                            boss2enemies.splice(index, 1)
                        }
                        m.timer--
                    })
                    //  Collision logic start
                    boss2enemies.forEach((enemy, enemyIndex) => {
                        if (pxpos < enemy.expos + 50 &&
                            pxpos + 50 > enemy.expos &&
                            pypos < enemy.eypos + 50 &&
                            pypos + 50 > enemy.eypos) {
                            if (isinvincible) {
                                return
                                boss2enemies.splice(enemyIndex, 1)
                            }
                            if (!isinvincible) {
                                // Remove one life
                                lifecount--
                                explosions.push({ id: blast, blastxpos: enemy.expos, blastypos: enemy.eypos, speed: enemy.speed, timer: 30 })
                                boss2enemies.splice(enemyIndex, 1)
                                isinvincible = true; // Set invincibility to prevent multiple collisions in a short time
                                setTimeout(() => {
                                    isinvincible = false; // Reset invincibility after 3 seconds
                                }, 3000)
                            }

                        }

                    })

                    //collision logic 


                    // enemy hit logic start
                    bullets.forEach((bull, bullindex) => {

                        boss2enemies.forEach((enemy, enemyIndex) => {

                            if (bull.bxpos < enemy.expos + 25 &&
                                bull.bxpos + 25 > enemy.expos &&
                                bull.bypos < enemy.eypos + 25 &&
                                bull.bypos + 25 > enemy.eypos
                            ) {
                                enemy.killcount = enemy.killcount - firepowercount - 1
                                bullets.splice(bullindex, 1) // Remove the bullet that hit the enemy
                                console.log(firepowercount)
                                console.log(enemy.killcount)
                                if (enemy.killcount <= 0) {
                                    bossexplo()
                                    enemy.killcount = 2
                                    boss2enemies.splice(enemyIndex, 1)

                                }



                            }

                        })
                    })
                }
                function rocketbosshealthdecrement(hitboss) {

                    hitboss.health -= 20
                    for (let i = 0; i < 2; i++) {
                        bossexplosions.push({
                            id: blast,
                            blastxpos: hitboss.x + Math.random() * 250, // spread across boss width
                            blastypos: hitboss.y + Math.random() * 150, // spread across boss height
                            speed: 0,
                            timer: 40 + (i * 10) // staggered timing
                        });
                    }
                    // TRIGGER DEATH ANIMATION
                    if (hitboss.health <= 0) {
                        handleBossDeath(hitboss);

                    }
                    return
                }

                requestAnimationFrame(animate)

            }


            animate();
        });
    </script>
</body>

</html>